
/***********/
/* debug.c */
/***********/

#ifdef _MEM_DEBUG
void* _debug_memcpy(void* dest, void* from, size_t size, int line, const char *func)
{
	printf("\n-");
	memcpy(dest, from, size);
	printf("- memcpy at %i, %s, %p[%li]\n\n", line, func, dest, size);
	fflush(stdout);
	return dest;
}
void* _debug_malloc(size_t size, int line, const char *func)
{
	printf("\n-");
	void *p = malloc(size);
	printf("- Allocation at %i, %s, %p[%li]\n\n", line, func, p, size);
	fflush(stdout);
	return p;
}

void _debug_free(void* ptr, int line, const char *func)
{
	printf("\n-");
	free(ptr);
	printf("- Free at %i, %s, %p\n\n", line, func, ptr);
	fflush(stdout);
}


#define malloc(X) _debug_malloc( X, __LINE__, __FUNCTION__)
#define free(X) _debug_free( X, __LINE__, __FUNCTION__)
#define memcpy(X, Y, Z) _debug_memcpy( X, Y, Z, __LINE__, __FUNCTION__)

#endif

#ifdef WIN32
#define _FILE_SEP '\\'
#else
#define _FILE_SEP '/'
#endif

#define __FILENAME__ (strrchr(__FILE__, _FILE_SEP) ? strrchr(__FILE__, _FILE_SEP) + 1 : __FILE__)


//TODO: replace all errors with this.
#define ASRT_CL(m)                                                                            \
    if(err!=CL_SUCCESS)                                                                       \
    {                                                                                         \
        fprintf(stderr, "ERROR: %s. (code: %i, line: %i, file:%s)\nPRESS ENTER TO EXIT\n", \
            m, err, __LINE__, __FILENAME__);                            \
        fflush(stderr);                                                 \
        while(1){char c; scanf("%c",&c); exit(1);}                      \
    }

/**********/
/* geom.c */
/**********/
#include <geom.h>
#define DEBUG_PRINT_VEC3(n, v) printf(n ": (%f, %f, %f)\n", v[0], v[1], v[2])


inline bool solve_quadratic(float *a, float *b, float *c, float *x0, float *x1)
{
    float discr = (*b) * (*b) - 4 * (*a) * (*c);

    if (discr < 0) return false;
    else if (discr == 0) {
        (*x0) = (*x1) = - 0.5 * (*b) / (*a);
    }
    else {
        float q = (*b > 0) ?
            -0.5 * (*b + sqrt(discr)) :
            -0.5 * (*b - sqrt(discr));
        *x0 = q / *a;
        *x1 = *c / q;
    }

    return true;
}

float* matvec_mul(mat4 m, vec4 v)
{
    float* out_float = (float*)malloc(sizeof(vec4));

    out_float[0] = m[0+0*4]*v[0] + m[0+1*4]*v[1] + m[0+2*4]*v[2] + m[0+3*4]*v[3];
    out_float[1] = m[1+0*4]*v[0] + m[1+1*4]*v[1] + m[1+2*4]*v[2] + m[1+3*4]*v[3];
    out_float[2] = m[2+0*4]*v[0] + m[2+1*4]*v[1] + m[2+2*4]*v[2] + m[2+3*4]*v[3];
    out_float[3] = m[3+0*4]*v[0] + m[3+1*4]*v[1] + m[3+2*4]*v[2] + m[3+3*4]*v[3];

    return out_float;
}

void swap_float(float *f1, float *f2)
{
    float temp = *f2;
    *f2 = *f1;
    *f1 = temp;
}

inline float does_collide_sphere(sphere s, ray r)
{
    float t0, t1; // solutions for t if the ray intersects


    vec3 L;
    xv_sub(L, r.orig, s.pos, 3);


    float a = 1.0f; //NOTE: we always normalize the direction vector.
    float b = xv3_dot(r.dir, L) * 2.0f;
    float c = xv3_dot(L, L) - (s.radius*s.radius); //NOTE: square can be optimized out.
    if (!solve_quadratic(&a, &b, &c, &t0, &t1)) return -1.0f;

    if (t0 > t1) swap_float(&t0, &t1);

    if (t0 < 0) {
        t0 = t1; // if t0 is negative, use t1 instead
        if (t0 < 0) return -1.0f; // both t0 and t1 are negative
    }

    return t0;
}

inline float does_collide_plane(plane p, ray r)
{
    float denom = xv_dot3(r.dir, p.norm);
    if (denom > 1e-6)
    {
        vec3 l;
        xv_sub(l, p.pos, r.orig, 3);
        float t = xv_dot3(l, p.norm) / denom;
        if (t >= 0)
            return -1.0;
        return t;
    }
    return -1.0;
}

ray generate_ray(int x, int y, int width, int height, float fov)
{
    ray r;

    //Simplified
    /* float ndc_x =((float)x+0.5)/width; */
    /* float ndc_y =((float)x+0.5)/height; */
    /* float screen_x = 2 ∗ ndc_x − 1; */
    /* float screen_y = 1 − 2 ∗ ndc_y; */
    /* float aspect_ratio = width/height; */
    /* float cam_x =(2∗screen_x−1) * tan(fov / 2 * M_PI / 180) ∗ aspect_ratio; */
    /* float cam_y = (1−2∗screen_y) * tan(fov / 2 * M_PI / 180); */

    float aspect_ratio = width / (float)height; // assuming width > height
    float cam_x = (2 * (((float)x + 0.5) / width) - 1) * tan(fov / 2 * M_PI / 180) * aspect_ratio;
    float cam_y = (1 - 2 * (((float)y + 0.5) / height)) * tan(fov / 2 * M_PI / 180);


    xv3_zero(r.orig);
    vec3 v1 = {cam_x, cam_y, -1};
    xv_sub(r.dir, v1, r.orig, 3);
    xv_normeq(r.dir, 3);

    return r;
}

/**********************/
/* irradiance_cache.c */
/**********************/

/******************************************/
/* NOTE: Irradiance Caching is Incomplete */
/******************************************/

#include <irradiance_cache.h>
#include <raytracer.h>
#include <parallel.h>

#ifdef WIN32
#define alloca _alloca
#endif
void ic_init(raytracer_context* rctx)
{
    rctx->ic_ctx->cl_standard_format.image_channel_order     = CL_RGBA;
    rctx->ic_ctx->cl_standard_format.image_channel_data_type = CL_FLOAT;

    rctx->ic_ctx->cl_standard_descriptor.image_type = CL_MEM_OBJECT_IMAGE2D;
    rctx->ic_ctx->cl_standard_descriptor.image_width = rctx->width;
    rctx->ic_ctx->cl_standard_descriptor.image_height = rctx->height;
    rctx->ic_ctx->cl_standard_descriptor.image_depth  = 0;
    rctx->ic_ctx->cl_standard_descriptor.image_array_size  = 0;
    rctx->ic_ctx->cl_standard_descriptor.image_row_pitch  = 0;
    rctx->ic_ctx->cl_standard_descriptor.num_mip_levels = 0;
    rctx->ic_ctx->cl_standard_descriptor.num_samples = 0;
    rctx->ic_ctx->cl_standard_descriptor.buffer = NULL;

    rctx->ic_ctx->octree.node_count = 1; //root
    //TODO: add as parameter
    rctx->ic_ctx->octree.max_depth = 8;  //arbitrary
    rctx->ic_ctx->octree.width     = 15; //arbitrary

    rctx->ic_ctx->octree.root = (ic_octree_node*) malloc(sizeof(ic_octree_node));
    rctx->ic_ctx->octree.root->min[0] = (float)-rctx->ic_ctx->octree.width;
    rctx->ic_ctx->octree.root->min[1] = (float)-rctx->ic_ctx->octree.width;
    rctx->ic_ctx->octree.root->min[2] = (float)-rctx->ic_ctx->octree.width;
    rctx->ic_ctx->octree.root->max[0] = (float) rctx->ic_ctx->octree.width;
    rctx->ic_ctx->octree.root->max[1] = (float) rctx->ic_ctx->octree.width;
    rctx->ic_ctx->octree.root->max[2] = (float) rctx->ic_ctx->octree.width;
    rctx->ic_ctx->octree.root->leaf = false;
    rctx->ic_ctx->octree.root->active = false;
}

void ic_octree_init_leaf(ic_octree_node* node, ic_octree_node* parent, unsigned int i)
{
    float xhalf = (parent->max[0]-parent->min[0])/2;
    float yhalf = (parent->max[1]-parent->min[1])/2;
    float zhalf = (parent->max[2]-parent->min[2])/2;
    node->active = false;

    node->leaf = true;
    for(int i = 0; i < 8; i++)
        node->data.branch.children[i] = NULL;
    node->min[0] = parent->min[0] + ( (i&4) ? xhalf : 0);
    node->min[1] = parent->min[1] + ( (i&2) ? yhalf : 0);
    node->min[2] = parent->min[2] + ( (i&1) ? zhalf : 0);
    node->max[0] = parent->max[0] - (!(i&4) ? xhalf : 0);
    node->max[1] = parent->max[1] - (!(i&2) ? yhalf : 0);
    node->max[2] = parent->max[2] - (!(i&1) ? zhalf : 0);
}

void ic_octree_make_branch(ic_octree* tree, ic_octree_node* node)
{

    node->leaf = false;
    for(int i = 0; i < 8; i++)
    {
        node->data.branch.children[i] = malloc(sizeof(ic_octree_node));
        ic_octree_init_leaf(node->data.branch.children[i], node, i);
        tree->node_count++;
    }
}

//TODO: test if points are the same
void _ic_octree_rec_resolve(ic_context* ictx, ic_octree_node* leaf, unsigned int node1, unsigned int node2,
                            unsigned int depth)
{
    if(depth > ictx->octree.max_depth)
    {
        //TODO: just group buffers together
        printf("ERROR: octree reached max depth when trying to resolve collision. (INCOMPLETE)\n");
        exit(1);
    }
    vec3 mid_point;
    xv_sub(mid_point, leaf->max, leaf->min, 3);
    xv_divieq(mid_point, 2, 3);
    unsigned int i1 =
        ((mid_point[0]<ictx->ir_buf[node1].point[0])<<2) |
        ((mid_point[1]<ictx->ir_buf[node1].point[1])<<1) |
        ((mid_point[2]<ictx->ir_buf[node1].point[2]));
    unsigned int i2 =
        ((mid_point[0]<ictx->ir_buf[node2].point[0])<<2) |
        ((mid_point[1]<ictx->ir_buf[node2].point[1])<<1) |
        ((mid_point[2]<ictx->ir_buf[node2].point[2]));
    ic_octree_make_branch(&ictx->octree, leaf);
    if(i1==i2)
        _ic_octree_rec_resolve(ictx, leaf->data.branch.children[i1], node1, node2, depth+1);
    else
    { //happiness
        leaf->data.branch.children[i1]->data.leaf.buffer_offset = node1;
        leaf->data.branch.children[i1]->data.leaf.num_elems = 1;
        leaf->data.branch.children[i2]->data.leaf.buffer_offset = node2;
        leaf->data.branch.children[i2]->data.leaf.num_elems = 1;
    }
}

void _ic_octree_rec_insert(ic_context* ictx, ic_octree_node* node, unsigned int v_ptr, unsigned int depth)
{
    if(node->leaf && !node->active)
    {
        node->active = true;
        node->data.leaf.buffer_offset = v_ptr;
        node->data.leaf.num_elems     = 1; //TODO: add suport for more than 1.
        return;
    }
    else if(node->leaf)
    {
        //resolve
        _ic_octree_rec_resolve(ictx, node, v_ptr, node->data.leaf.buffer_offset, depth+1);
    }
    else
    {
        ic_octree_node* new_node = node->data.branch.children[
            ((ictx->ir_buf[node->data.leaf.buffer_offset].point[0]<ictx->ir_buf[v_ptr].point[0])<<2) |
            ((ictx->ir_buf[node->data.leaf.buffer_offset].point[1]<ictx->ir_buf[v_ptr].point[1])<<1) |
            ((ictx->ir_buf[node->data.leaf.buffer_offset].point[2]<ictx->ir_buf[v_ptr].point[2]))];
        _ic_octree_rec_insert(ictx, new_node, v_ptr, depth+1);
    }
}

void ic_octree_insert(ic_context* ictx, vec3 point, vec3 normal)
{
    if(ictx->ir_buf_current_offset==ictx->ir_buf_size) //TODO: dynamically resize or do something else
    {
        printf("ERROR: irradiance buffer is full!\n");
        exit(1);
    }
    ic_ir_value irradiance_value; //TODO: EVALUATE THIS
    ictx->ir_buf[ictx->ir_buf_current_offset++] = irradiance_value;
    _ic_octree_rec_insert(ictx, ictx->octree.root, ictx->ir_buf_current_offset, 0);
}

//NOTE: outBuffer is only bools but using char for safety accross compilers.
//      Also assuming that buf is grayscale
void dither(float* buf, const int width, const int height)
{
    for(int y = 0; y < height; y++ )
    {
        for(int x = 0; x < width; x++ )
        {
            float oldpixel  = buf[x+y*width];
            float newpixel  = oldpixel>0.5f ? 1 : 0;
            buf[x+y*width]  = newpixel;
            float err = oldpixel - newpixel;

            if( (x != (width-1)) && (x != 0) && (y != (height-1)) )
            {
                buf[(x+1)+(y  )*width] = buf[(x+1)+(y  )*width] + err  * (7.f / 16.f);
                buf[(x-1)+(y+1)*width] = buf[(x-1)+(y+1)*width] + err  * (3.f / 16.f);
                buf[(x  )+(y+1)*width] = buf[(x  )+(y+1)*width] + err  * (5.f / 16.f);
                buf[(x+1)+(y+1)*width] = buf[(x+1)+(y+1)*width] + err  * (1.f / 16.f);
            }
        }
    }
}


void get_geom_maps(raytracer_context* rctx, cl_mem positions, cl_mem normals)
{
    int err;

    cl_kernel kernel = rctx->program->raw_kernels[IC_SCREEN_TEX_KRNL_INDX];

    float zeroed[] = {0., 0., 0., 1.};
    float* result = matvec_mul(rctx->stat_scene->camera_world_matrix, zeroed);

    //SO MANY ARGUEMENTS
    clSetKernelArg(kernel, 0, sizeof(cl_mem),  &positions);
    clSetKernelArg(kernel, 1, sizeof(cl_mem),  &normals);
    clSetKernelArg(kernel, 2, sizeof(int),     &rctx->width);
    clSetKernelArg(kernel, 3, sizeof(int),     &rctx->height);
    clSetKernelArg(kernel, 4, sizeof(cl_mem),  &rctx->cl_ray_buffer);
    clSetKernelArg(kernel, 5, sizeof(vec4),    result);
    clSetKernelArg(kernel, 6, sizeof(cl_mem),  &rctx->stat_scene->cl_material_buffer);
    clSetKernelArg(kernel, 7, sizeof(cl_mem),  &rctx->stat_scene->cl_sphere_buffer);
    clSetKernelArg(kernel, 8, sizeof(cl_mem),  &rctx->stat_scene->cl_plane_buffer);
    clSetKernelArg(kernel, 9, sizeof(cl_mem),  &rctx->stat_scene->cl_mesh_buffer);
    clSetKernelArg(kernel, 10, sizeof(cl_mem), &rctx->stat_scene->cl_mesh_index_buffer);
    clSetKernelArg(kernel, 11, sizeof(cl_mem), &rctx->stat_scene->cl_mesh_vert_buffer);
    clSetKernelArg(kernel, 12, sizeof(cl_mem), &rctx->stat_scene->cl_mesh_nrml_buffer);

    size_t global = rctx->width*rctx->height;
    size_t local = 0;
    err = clGetKernelWorkGroupInfo(kernel, rctx->rcl->device_id, CL_KERNEL_WORK_GROUP_SIZE,
                                   sizeof(local), &local, NULL);
    ASRT_CL("Failed to Retrieve Kernel Work Group Info");

    err = clEnqueueNDRangeKernel(rctx->rcl->commands, kernel, 1, NULL, &global,
                                 NULL, 0, NULL, NULL);
    ASRT_CL("Failed to Enqueue kernel IC_SCREEN_TEX");

    //Wait for completion
    err = clFinish(rctx->rcl->commands);
    ASRT_CL("Something happened while waiting for kernel to finish");
}

void gen_mipmap_chain_gb(raytracer_context* rctx, cl_mem texture,
                         ic_mipmap_gb* mipmaps, int num_mipmaps)
{
    int err;
    unsigned int width  = rctx->width;
    unsigned int height = rctx->height;
    cl_kernel kernel = rctx->program->raw_kernels[IC_MIP_REDUCE_KRNL_INDX];
    for(int i = 0; i < num_mipmaps; i++)
    {
        mipmaps[i].width  = width;
        mipmaps[i].height = height;

        if(i==0)
        {
            mipmaps[0].cl_image_ref = texture;

            height /= 2;
            width /= 2;
            continue;
        }

        clSetKernelArg(kernel, 0, sizeof(cl_mem), &mipmaps[i-1].cl_image_ref);
        clSetKernelArg(kernel, 1, sizeof(cl_mem), &mipmaps[i].cl_image_ref);
        clSetKernelArg(kernel, 2, sizeof(int),    &width);
        clSetKernelArg(kernel, 3, sizeof(int),    &height);

        size_t global = width*height;
        size_t local = get_workgroup_size(rctx, kernel);

        err = clEnqueueNDRangeKernel(rctx->rcl->commands, kernel, 1,
                                     NULL, &global, NULL, 0, NULL, NULL);
        ASRT_CL("Failed to Enqueue kernel IC_MIP_REDUCE");

        height /= 2;
        width /= 2;
        //Wait for completion before doing next mip
        err = clFinish(rctx->rcl->commands);
        ASRT_CL("Something happened while waiting for kernel to finish");
    }
}

void upsample_mipmaps_f(raytracer_context* rctx, cl_mem texture,
                        ic_mipmap_f* mipmaps, int num_mipmaps)
{
    int err;

    cl_mem* full_maps = (cl_mem*) alloca(sizeof(cl_mem)*num_mipmaps);
    for(int i = 1; i < num_mipmaps; i++)
    {
        full_maps[i] = gen_grayscale_buffer(rctx, 0, 0);
    }
    full_maps[0] = texture;
    { //Upsample
        for(int i = 0; i < num_mipmaps; i++) //First one is already at proper resolution
        {
            cl_kernel kernel = rctx->program->raw_kernels[IC_MIP_S_UPSAMPLE_SCALED_KRNL_INDX];

            clSetKernelArg(kernel, 0, sizeof(cl_mem), &mipmaps[i].cl_image_ref);
            clSetKernelArg(kernel, 1, sizeof(cl_mem), &full_maps[i]); //NOTE: need to generate this for the function
            clSetKernelArg(kernel, 2, sizeof(int),    &i);
            clSetKernelArg(kernel, 3, sizeof(int),    &rctx->width);
            clSetKernelArg(kernel, 4, sizeof(int),    &rctx->height);

            size_t global = rctx->width*rctx->height;
            size_t local = get_workgroup_size(rctx, kernel);

            err = clEnqueueNDRangeKernel(rctx->rcl->commands, kernel, 1,
                                         NULL, &global, NULL, 0, NULL, NULL);
            ASRT_CL("Failed to Enqueue kernel IC_MIP_S_UPSAMPLE_SCALED");

        }
        err = clFinish(rctx->rcl->commands);
        ASRT_CL("Something happened while waiting for kernel to finish");
    }
    printf("Upsampled Discontinuity Mipmaps\nAveraging Upsampled Discontinuity Mipmaps\n");

    { //Average
        int total = num_mipmaps;
        for(int i = 0; i < num_mipmaps; i++) //First one is already at proper resolution
        {
            cl_kernel kernel = rctx->program->raw_kernels[IC_FLOAT_AVG_KRNL_INDX];

            clSetKernelArg(kernel, 0, sizeof(cl_mem), &full_maps[i]);
            clSetKernelArg(kernel, 1, sizeof(cl_mem), &texture);
            clSetKernelArg(kernel, 2, sizeof(int),    &rctx->width);
            clSetKernelArg(kernel, 3, sizeof(int),    &rctx->height);
            clSetKernelArg(kernel, 4, sizeof(int),    &total);

            size_t global = rctx->width*rctx->height;
            size_t local = 0;
            err = clGetKernelWorkGroupInfo(kernel, rctx->rcl->device_id, CL_KERNEL_WORK_GROUP_SIZE,
                                           sizeof(local), &local, NULL);
            ASRT_CL("Failed to Retrieve Kernel Work Group Info");

            err = clEnqueueNDRangeKernel(rctx->rcl->commands, kernel, 1,
                                         NULL, &global, NULL, 0, NULL, NULL);
            ASRT_CL("Failed to Enqueue kernel IC_FLOAT_AVG");

            err = clFinish(rctx->rcl->commands);
            ASRT_CL("Something happened while waiting for kernel to finish");
        }
    }
    for(int i = 1; i < num_mipmaps; i++)
    {
        err = clReleaseMemObject(full_maps[i]);
        ASRT_CL("Failed to cleanup fullsize mipmaps");
    }
}

void gen_discontinuity_maps(raytracer_context* rctx, ic_mipmap_gb* pos_mipmaps,
                            ic_mipmap_gb* nrm_mipmaps, ic_mipmap_f* disc_mipmaps,
                            int num_mipmaps)
{
    int err;
    //TODO: tune k and intensity
    const float k = 1.6f;
    const float intensity = 0.02f;
    for(int i = 0; i < num_mipmaps; i++)
    {
        cl_kernel kernel = rctx->program->raw_kernels[IC_GEN_DISC_KRNL_INDX];
        disc_mipmaps[i].width  = pos_mipmaps[i].width;
        disc_mipmaps[i].height = pos_mipmaps[i].height;

        clSetKernelArg(kernel, 0, sizeof(cl_mem), &pos_mipmaps[i].cl_image_ref);


        clSetKernelArg(kernel, 1, sizeof(cl_mem), &nrm_mipmaps[i].cl_image_ref);
        clSetKernelArg(kernel, 2, sizeof(cl_mem), &disc_mipmaps[i].cl_image_ref);
        clSetKernelArg(kernel, 3, sizeof(float),  &k);
        clSetKernelArg(kernel, 4, sizeof(float),  &intensity);
        clSetKernelArg(kernel, 5, sizeof(int),    &pos_mipmaps[i].width);
        clSetKernelArg(kernel, 6, sizeof(int),    &pos_mipmaps[i].height);

        size_t global = pos_mipmaps[i].width*pos_mipmaps[i].height;
        size_t local = get_workgroup_size(rctx, kernel);

        err = clEnqueueNDRangeKernel(rctx->rcl->commands, kernel, 1,
                                     NULL, &global, NULL, 0, NULL, NULL);
        ASRT_CL("Failed to Enqueue kernel IC_GEN_DISC");

    }
    err = clFinish(rctx->rcl->commands);
    ASRT_CL("Something happened while waiting for kernel to finish");
}

void ic_screenspace(raytracer_context* rctx)
{
    int err;


    vec4*   pos_tex = (vec4*) malloc(rctx->width*rctx->height*sizeof(vec4));
    vec4*   nrm_tex = (vec4*) malloc(rctx->width*rctx->height*sizeof(vec4));
    float*  c_fin_disc_map = (float*) malloc(rctx->width*rctx->height*sizeof(float));

    ic_mipmap_gb pos_mipmaps [NUM_MIPMAPS]; //A lot of buffers
    ic_mipmap_gb nrm_mipmaps [NUM_MIPMAPS];
    ic_mipmap_f  disc_mipmaps[NUM_MIPMAPS];
    cl_mem       fin_disc_map;
    //OpenCL
    cl_mem cl_pos_tex;
    cl_mem cl_nrm_tex;
    cl_image_desc cl_mipmap_descriptor = rctx->ic_ctx->cl_standard_descriptor;

    { //OpenCL Init
        cl_pos_tex = gen_rgb_image(rctx, 0,0);
        cl_nrm_tex = gen_rgb_image(rctx, 0,0);

        fin_disc_map = gen_grayscale_buffer(rctx, 0,0);
        zero_buffer_img(rctx, fin_disc_map, sizeof(float), 0, 0);


        unsigned int width  = rctx->width,
                     height = rctx->height;
        for(int i = 0; i < NUM_MIPMAPS; i++)
        {
            if(i!=0)
            {
                pos_mipmaps[i].cl_image_ref = gen_rgb_image(rctx, width, height);
                nrm_mipmaps[i].cl_image_ref = gen_rgb_image(rctx, width, height);
            }
            disc_mipmaps[i].cl_image_ref = gen_grayscale_buffer(rctx, width, height);

            width /= 2;
            height /= 2;
        }
    }
    printf("Initialised Irradiance Cache Screenspace Buffers\nGetting Screenspace Geometry Data\n");
    get_geom_maps(rctx, cl_pos_tex, cl_nrm_tex);
    printf("Got Screenspace Geometry Data\nGenerating MipMaps\n");
    gen_mipmap_chain_gb(rctx, cl_pos_tex,
                        pos_mipmaps, NUM_MIPMAPS);
    gen_mipmap_chain_gb(rctx, cl_nrm_tex,
                        nrm_mipmaps, NUM_MIPMAPS);
    printf("Generated MipMaps\nGenerating Discontinuity Map for each Mip\n");
    gen_discontinuity_maps(rctx, pos_mipmaps, nrm_mipmaps, disc_mipmaps, NUM_MIPMAPS);
    printf("Generated Discontinuity Map for each Mip\nUpsampling Discontinuity Mipmaps\n");
    upsample_mipmaps_f(rctx, fin_disc_map, disc_mipmaps, NUM_MIPMAPS);
    printf("Averaged Upsampled Discontinuity Mipmaps\nRetrieving Discontinuity Data\n");
    retrieve_buf(rctx, fin_disc_map, c_fin_disc_map,
                 rctx->width*rctx->height*sizeof(float));
    retrieve_image(rctx, cl_pos_tex, pos_tex, 0, 0);
    retrieve_image(rctx, cl_pos_tex, pos_tex, 0, 0);

    printf("Retrieved Discontinuity Data\nDithering Discontinuity Map\n");
    //NOTE: read buffer is blocking so we don't need clFinish
    dither(c_fin_disc_map, rctx->width, rctx->height);
    err = clEnqueueWriteBuffer(rctx->rcl->commands, fin_disc_map,
                               CL_TRUE, 0,
                               rctx->width*rctx->height*sizeof(float),
                                   c_fin_disc_map, 0, 0, NULL);
    ASRT_CL("Failed to write dithered discontinuity map");


    //INSERT
    cl_kernel kernel = rctx->program->raw_kernels[BLIT_FLOAT_OUTPUT_INDX];

    clSetKernelArg(kernel, 0, sizeof(cl_mem), &rctx->cl_output_buffer);
    clSetKernelArg(kernel, 1, sizeof(cl_mem), &fin_disc_map);
    clSetKernelArg(kernel, 2, sizeof(int),    &rctx->width);
    clSetKernelArg(kernel, 3, sizeof(int),    &rctx->height);

    size_t global = rctx->width*rctx->height;
    size_t local = 0;
    err = clGetKernelWorkGroupInfo(kernel, rctx->rcl->device_id, CL_KERNEL_WORK_GROUP_SIZE,
                                   sizeof(local), &local, NULL);
    ASRT_CL("Failed to Retrieve Kernel Work Group Info");

    err = clEnqueueNDRangeKernel(rctx->rcl->commands, kernel, 1,
                                 NULL, &global, NULL, 0, NULL, NULL);
    ASRT_CL("Failed to Enqueue kernel BLIT_FLOAT_OUTPUT_INDX");

    clFinish(rctx->rcl->commands);

    err = clEnqueueReadBuffer(rctx->rcl->commands, rctx->cl_output_buffer, CL_TRUE, 0,
                              rctx->width*rctx->height*sizeof(int), rctx->output_buffer, 0, NULL, NULL );
    ASRT_CL("Failed to Read Output Buffer");
    printf("test!!\n");


}




/************/
/* loader.c */
/************/
#include <loader.h>
#include <parson.h>
#include <vec.h>
#include <float.h>
#include <tinyobj_loader_c.h>
#include <assert.h>



#ifndef WIN32
#include <libproc.h>
#include <unistd.h>

#define FILE_SEP '/'

char* _get_os_pid_bin_path()
{
    static bool initialised = false;
    static char path[PROC_PIDPATHINFO_MAXSIZE];
    if(!initialised)
    {
        int ret;
        pid_t pid;
        char path[PROC_PIDPATHINFO_MAXSIZE];

        pid = getpid();
        ret = proc_pidpath(pid, path, sizeof(path));

        if(ret <= 0)
        {
            printf("Error: couldn't get bin path.\n");
            exit(1);
        }
    }
    return path;
}
#else
#include <windows.h>
#define FILE_SEP '\\'

char* _get_os_pid_bin_path()
{
    static bool initialised = false;
    static char path[260];
    if(!initialised)
    {
        HMODULE hModule = GetModuleHandleW(NULL);

        WCHAR tpath[260];
        GetModuleFileNameW(hModule, tpath, 260);

        char DefChar = ' ';
        WideCharToMultiByte(CP_ACP, 0, tpath, -1, path, 260, &DefChar, NULL);

        *(strrchr(path, FILE_SEP)) = '\0'; //get last occurence;

    }
	return path;
}
#endif

char* load_file(const char* url, long *ret_length)
{
    char real_url[260];
    sprintf(real_url, "%s%cres%c%s", _get_os_pid_bin_path(), FILE_SEP, FILE_SEP, url);

    char * buffer = 0;
    long length;
    FILE * f = fopen (real_url, "rb");

    if (f)
    {
        fseek (f, 0, SEEK_END);
        length = ftell (f)+1;
        fseek (f, 0, SEEK_SET);
        buffer = malloc (length);
        if (buffer)
        {
            fread (buffer, 1, length, f);
        }
        fclose (f);
    }
    if (buffer)
    {
        buffer[length] = '\0';

        *ret_length = length;
        return buffer;
    }
    else
    {
        printf("Error: Couldn't load file '%s'.\n", real_url);
        exit(1);
    }
}


//Linked List for Mesh loading
struct obj_list_elem
{
    struct obj_list_elem* next;
    tinyobj_attrib_t attrib;
    tinyobj_shape_t* shapes;
    size_t num_shapes;
    int mat_index;
    mat4 model_mat;
};

void obj_pre_load(char* data, long data_len, struct obj_list_elem* elem,
                  int* num_meshes, unsigned int* num_indices, unsigned int* num_vertices,
                  unsigned int* num_normals, unsigned int* num_texcoords)
{

    tinyobj_material_t* materials = NULL; //NOTE: UNUSED
    size_t num_materials;                 //NOTE: UNUSED


    {
        unsigned int flags = TINYOBJ_FLAG_TRIANGULATE;
        int ret = tinyobj_parse_obj(&elem->attrib, &elem->shapes, &elem->num_shapes, &materials,
                                    &num_materials, data, data_len, flags);
        if (ret != TINYOBJ_SUCCESS) {
            printf("Error: Couldn't parse mesh.\n");
            exit(1);
        }
    }

    *num_vertices  += elem->attrib.num_vertices;
    *num_normals   += elem->attrib.num_normals;
    *num_texcoords += elem->attrib.num_texcoords;
    *num_meshes    += elem->num_shapes;
    //tinyobjloader has dumb variable names: attrib.num_faces =  num_vertices+num_faces
    *num_indices   += elem->attrib.num_faces;
}



void load_obj(struct obj_list_elem elem, int* mesh_offset, int* vert_offset, int* nrml_offset,
                      int* texcoord_offset, int* index_offset, scene* out_scene)
{
    for(int i = 0; i < elem.num_shapes; i++)
    {
        tinyobj_shape_t shape = elem.shapes[i];

        //Get mesh and increment offset.
        mesh* m = (out_scene->meshes) + (*mesh_offset)++;

        m->min[0] = m->min[1] = m->min[2] =  FLT_MAX;
        m->max[0] = m->max[1] = m->max[2] = -FLT_MAX;

        memcpy(m->model, elem.model_mat, 4*4*sizeof(float));

        m->index_offset = *index_offset;
        m->num_indices  =  shape.length*3;
        m->material_index    =  elem.mat_index;

        for(int f = 0; f < shape.length; f++)
        {
            //TODO: don't do this error check for each iteration
            if(elem.attrib.face_num_verts[f+shape.face_offset]!=3)
            {
                //This should never get called because the mesh gets triangulated when loaded.
                printf("Error: the obj loader only supports triangulated meshes!\n");
                exit(1);
            }
            for(int i = 0; i < 3; i++)
            {
                tinyobj_vertex_index_t face_index = elem.attrib.faces[(f+shape.face_offset)*3+i];

                vec3 vertex;
                vertex[0] = elem.attrib.vertices[3*face_index.v_idx+0];
                vertex[1] = elem.attrib.vertices[3*face_index.v_idx+1];
                vertex[2] = elem.attrib.vertices[3*face_index.v_idx+2];

                m->min[0] = vertex[0] < m->min[0] ? vertex[0] : m->min[0]; //X min
                m->min[1] = vertex[1] < m->min[1] ? vertex[1] : m->min[1]; //Y min
                m->min[2] = vertex[2] < m->min[2] ? vertex[2] : m->min[2]; //Z min

                m->max[0] = vertex[0] > m->max[0] ? vertex[0] : m->max[0]; //X max
                m->max[1] = vertex[1] > m->max[1] ? vertex[1] : m->max[1]; //Y max
                m->max[2] = vertex[2] > m->max[2] ? vertex[2] : m->max[2]; //Z max

                ivec3 index;
                index[0] = (*vert_offset)+face_index.v_idx;
                index[1] = (*nrml_offset)+face_index.vn_idx;
                index[2] = (*texcoord_offset)+face_index.vt_idx;
                out_scene->mesh_indices[(*index_offset)][0] = index[0];
                out_scene->mesh_indices[(*index_offset)][1] = index[1];
                out_scene->mesh_indices[(*index_offset)][2] = index[2];

                //xv3_cpy(out_scene->mesh_indices + (*index_offset), index);
                (*index_offset)++;
            }
        }
    }

    //GPU MEMORY ALIGNMENT FUN
    //NOTE: this is done because the gpu stores all vec3s 4 floats for memory alignment
    //      and it is actually faster if they are aligned like this even
    //      though it wastes more memory.
    for(int i = 0; i < elem.attrib.num_vertices; i++)
    {

        memcpy(out_scene->mesh_verts + (*vert_offset),
               elem.attrib.vertices+3*i,
               sizeof(vec3));
        (*vert_offset) += 1;
    }
    for(int i = 0; i < elem.attrib.num_normals; i++)
    {
        memcpy(out_scene->mesh_nrmls + (*nrml_offset),
               elem.attrib.normals+3*i,
               sizeof(vec3));
        (*nrml_offset) += 1;
    }
    //NOTE: the texcoords are already aligned because they only have 2 elements.
    memcpy(out_scene->mesh_texcoords + (*texcoord_offset), elem.attrib.texcoords,
           elem.attrib.num_texcoords*sizeof(vec2));
    (*texcoord_offset) += elem.attrib.num_texcoords;
}

scene* load_scene_json(char* json)
{
    printf("Beginning scene loading...\n");
    scene* out_scene = (scene*) malloc(sizeof(scene));
	JSON_Value *root_value;
    JSON_Object *root_object;
	root_value = json_parse_string(json);
    root_object = json_value_get_object(root_value);


    //Name
    {
        const char* name = json_object_get_string(root_object, "name");
        printf("Scene name: %s\n", name);
    }

    //Version
    {//TODO: do something with this.
        int major  = (int)json_object_dotget_number(root_object, "version.major");
        int minor  = (int)json_object_dotget_number(root_object, "version.major");
        const char* type =      json_object_dotget_string(root_object, "version.type");
    }

    //Materials
    {
        JSON_Array* material_array = json_object_get_array(root_object, "materials");
        out_scene->num_materials   = json_array_get_count(material_array);
        out_scene->materials = (material*) malloc(out_scene->num_materials*sizeof(material));
        assert(out_scene->num_materials>0);
        for(int i = 0; i < out_scene->num_materials; i++)
        {
            JSON_Object* mat = json_array_get_object(material_array, i);
            xv_x(out_scene->materials[i].colour) = json_object_get_number(mat, "r");
            xv_y(out_scene->materials[i].colour) = json_object_get_number(mat, "g");
            xv_z(out_scene->materials[i].colour) = json_object_get_number(mat, "b");
            out_scene->materials[i].reflectivity = json_object_get_number(mat, "reflectivity");
        }
        printf("Materials: %d\n", out_scene->num_materials);
    }

    //Primitives
    {

        JSON_Object* primitive_object = json_object_get_object(root_object, "primitives");

        //Spheres
        {
            JSON_Array* sphere_array = json_object_get_array(primitive_object, "spheres");
            int num_spheres = json_array_get_count(sphere_array);

            out_scene->spheres = malloc(sizeof(sphere)*num_spheres);
            out_scene->num_spheres = num_spheres;

            for(int i = 0; i < num_spheres; i++)
            {
                JSON_Object* sphere = json_array_get_object(sphere_array, i);
                out_scene->spheres[i].pos[0] = json_object_get_number(sphere, "x");
                out_scene->spheres[i].pos[1] = json_object_get_number(sphere, "y");
                out_scene->spheres[i].pos[2] = json_object_get_number(sphere, "z");
                out_scene->spheres[i].radius = json_object_get_number(sphere, "radius");
                out_scene->spheres[i].material_index = json_object_get_number(sphere, "mat_index");
            }
            printf("Spheres: %d\n", out_scene->num_spheres);
        }

        //Planes
        {
            JSON_Array* plane_array = json_object_get_array(primitive_object, "planes");
            int num_planes = json_array_get_count(plane_array);

            out_scene->planes = malloc(sizeof(plane)*num_planes);
            out_scene->num_planes = num_planes;

            for(int i = 0; i < num_planes; i++)
            {
                JSON_Object* plane = json_array_get_object(plane_array, i);
                out_scene->planes[i].pos[0] = json_object_get_number(plane, "x");
                out_scene->planes[i].pos[1] = json_object_get_number(plane, "y");
                out_scene->planes[i].pos[2] = json_object_get_number(plane, "z");
                out_scene->planes[i].norm[0] = json_object_get_number(plane, "nx");
                out_scene->planes[i].norm[1] = json_object_get_number(plane, "ny");
                out_scene->planes[i].norm[2] = json_object_get_number(plane, "nz");

                out_scene->planes[i].material_index = json_object_get_number(plane, "mat_index");
            }
            printf("Planes: %d\n", out_scene->num_planes);
        }

    }


    //Meshes
    {
        JSON_Array* mesh_array = json_object_get_array(root_object, "meshes");

        int num_meshes = json_array_get_count(mesh_array);

        out_scene->num_meshes = 0;
        out_scene->num_mesh_verts = 0;
        out_scene->num_mesh_nrmls = 0;
        out_scene->num_mesh_texcoords = 0;
        out_scene->num_mesh_indices = 0;


        struct obj_list_elem* first = (struct obj_list_elem*) malloc(sizeof(struct obj_list_elem));
        struct obj_list_elem* current = first;

        //Pre evaluation
        for(int i = 0; i < num_meshes; i++)
        {
            JSON_Object* mesh = json_array_get_object(mesh_array, i);
            const char* url = json_object_get_string(mesh, "url");
            long length;
            char* data = load_file(url, &length);
            obj_pre_load(data, length, current, &out_scene->num_meshes, &out_scene->num_mesh_indices,
                         &out_scene->num_mesh_verts, &out_scene->num_mesh_nrmls,
                         &out_scene->num_mesh_texcoords);
            current->mat_index = (int) json_object_get_number(mesh, "mat_index");
            //mat4 model_mat;
            {
                //xm4_identity(model_mat);
                mat4 translation_mat;
                xm4_translatev(translation_mat,
                               json_object_get_number(mesh, "px"),
                               json_object_get_number(mesh, "py"),
                               json_object_get_number(mesh, "pz"));
                mat4 scale_mat;
                xm4_scalev(scale_mat,
                           json_object_get_number(mesh, "sx"),
                           json_object_get_number(mesh, "sy"),
                           json_object_get_number(mesh, "sz"));
                //TODO: add rotation.
                xm4_mul(current->model_mat, translation_mat, scale_mat);
            }
            free(data);

            if(i!=num_meshes-1) //messy but it works
            {
                current->next = (struct obj_list_elem*) malloc(sizeof(struct obj_list_elem));
                current = current->next;
            }
            current->next = NULL;
        }

        //Allocation
        out_scene->meshes          = (mesh*) malloc(sizeof(mesh)*out_scene->num_meshes);
        out_scene->mesh_verts      = (vec3*) malloc(sizeof(vec3)*out_scene->num_mesh_verts);
        out_scene->mesh_nrmls      = (vec3*) malloc(sizeof(vec3)*out_scene->num_mesh_nrmls);
        out_scene->mesh_texcoords  = (vec2*) malloc(sizeof(vec2)*out_scene->num_mesh_texcoords);
        out_scene->mesh_indices    = (ivec3*) malloc(sizeof(ivec3)*out_scene->num_mesh_indices);

        assert(out_scene->meshes!=NULL);
        assert(out_scene->mesh_verts!=NULL);
        assert(out_scene->mesh_nrmls!=NULL);
        assert(out_scene->mesh_texcoords!=NULL);
        assert(out_scene->mesh_indices!=NULL);

        //Parsing and Assignment
        int mesh_offset = 0;
        int vert_offset = 0;
        int nrml_offset = 0;
        int texcoord_offset = 0;
        int index_offset = 0;


        current = first;
        while(current != NULL && num_meshes)
        {

            load_obj(*current, &mesh_offset, &vert_offset, &nrml_offset, &texcoord_offset,
                     &index_offset, out_scene);

            current = current->next;
        }
        printf("%i and %i\n", vert_offset, out_scene->num_mesh_verts);
        assert(mesh_offset==out_scene->num_meshes);
        assert(vert_offset==out_scene->num_mesh_verts);
        assert(nrml_offset==out_scene->num_mesh_nrmls);
        assert(texcoord_offset==out_scene->num_mesh_texcoords);

        assert(index_offset==out_scene->num_mesh_indices);

        printf("Meshes: %d\nVertices: %d\nIndices: %d\n",
               out_scene->num_meshes, out_scene->num_mesh_verts, out_scene->num_mesh_indices);

    }

    out_scene->materials_changed = true;
    out_scene->spheres_changed = true;
    out_scene->planes_changed = true;
    out_scene->meshes_changed = true;


    printf("Finshed scene loading.\n\n");

	json_value_free(root_value);
	return out_scene;
}


scene* load_scene_json_url(char* url)
{
    long variable_doesnt_matter;

    return load_scene_json( load_file(url, &variable_doesnt_matter) ); //TODO: put data
}


/************/
/* os_abs.c */
/************/
#include <os_abs.h>

void os_start(os_abs abs)
{
    (*abs.start_func)();
}

void os_loop_start(os_abs abs)
{
    (*abs.loop_start_func)();
}

void os_update(os_abs abs)
{
    (*abs.update_func)();
}

void os_sleep(os_abs abs, int num)
{
    (*abs.sleep_func)(num);
}

void* os_get_bitmap_memory(os_abs abs)
{
    return (*abs.get_bitmap_memory_func)();
}

int os_get_time_mili(os_abs abs)
{
    return (*abs.get_time_mili_func)();
}

int os_get_width(os_abs abs)
{
    return (*abs.get_width_func)();
}

int os_get_height(os_abs abs)
{
    return (*abs.get_height_func)();
}

void os_start_thread(os_abs abs, void (*func)(void*), void* data)
{
    (*abs.start_thread_func)(func, data);
}

/**************/
/* parallel.c */
/**************/
#include <CL/opencl.h>
#include <raytracer.h>
//Parallel util.

void cl_info()
{

    int i, j;
    char* value;
    size_t valueSize;
    cl_uint platformCount;
    cl_platform_id* platforms;
    cl_uint deviceCount;
    cl_device_id* devices;
    cl_uint maxComputeUnits;

    // get all platforms
    clGetPlatformIDs(0, NULL, &platformCount);
    platforms = (cl_platform_id*) malloc(sizeof(cl_platform_id) * platformCount);
    clGetPlatformIDs(platformCount, platforms, NULL);

    for (i = 0; i < platformCount; i++) {

        // get all devices
        clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, 0, NULL, &deviceCount);
        devices = (cl_device_id*) malloc(sizeof(cl_device_id) * deviceCount);
        clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_ALL, deviceCount, devices, NULL);

        // for each device print critical attributes
        for (j = 0; j < deviceCount; j++) {

            // print device name
            clGetDeviceInfo(devices[j], CL_DEVICE_NAME, 0, NULL, &valueSize);
            value = (char*) malloc(valueSize);
            clGetDeviceInfo(devices[j], CL_DEVICE_NAME, valueSize, value, NULL);
            printf("%i.%d. Device: %s\n", i, j+1, value);
            free(value);

            // print hardware device version
            clGetDeviceInfo(devices[j], CL_DEVICE_VERSION, 0, NULL, &valueSize);
            value = (char*) malloc(valueSize);
            clGetDeviceInfo(devices[j], CL_DEVICE_VERSION, valueSize, value, NULL);
            printf(" %i.%d.%d Hardware version: %s\n", i, j+1, 1, value);
            free(value);

            // print software driver version
            clGetDeviceInfo(devices[j], CL_DRIVER_VERSION, 0, NULL, &valueSize);
            value = (char*) malloc(valueSize);
            clGetDeviceInfo(devices[j], CL_DRIVER_VERSION, valueSize, value, NULL);
            printf(" %i.%d.%d Software version: %s\n", i, j+1, 2, value);
            free(value);

            // print c version supported by compiler for device
            clGetDeviceInfo(devices[j], CL_DEVICE_OPENCL_C_VERSION, 0, NULL, &valueSize);
            value = (char*) malloc(valueSize);
            clGetDeviceInfo(devices[j], CL_DEVICE_OPENCL_C_VERSION, valueSize, value, NULL);
            printf(" %i.%d.%d OpenCL C version: %s\n", i, j+1, 3, value);
            free(value);

            // print parallel compute units
            clGetDeviceInfo(devices[j], CL_DEVICE_MAX_COMPUTE_UNITS,
                    sizeof(maxComputeUnits), &maxComputeUnits, NULL);
            printf(" %i.%d.%d Parallel compute units: %d\n", i,  j+1, 4, maxComputeUnits);

        }

        free(devices);

    }
    printf("\n");
    free(platforms);
    return;
}
void pfn_notify (
    const char *errinfo,
    const void *private_info,
    size_t cb,
    void *user_data)
{
    fprintf(stderr, "\n--\nOpenCL ERROR: %s\n--\n", errinfo);
    fflush(stderr);
}
void create_context(rcl_ctx* ctx)
{
    int err = CL_SUCCESS;


    int num_of_platforms;

    if (clGetPlatformIDs(0, NULL, &num_of_platforms) != CL_SUCCESS)
    {
        printf("Error: Unable to get platform_id\n");
        exit(1);
    }
    cl_platform_id *platform_ids = malloc(num_of_platforms*sizeof(cl_platform_id));
    if (clGetPlatformIDs(num_of_platforms, platform_ids, NULL) != CL_SUCCESS)
    {
        printf("Error: Unable to get platform_id\n");
        exit(1);
    }
    bool found = false;
    for(int i=0; i<num_of_platforms; i++)
        if(clGetDeviceIDs(platform_ids[i], CL_DEVICE_TYPE_GPU, 1, &ctx->device_id, NULL) == CL_SUCCESS)
        {
            found = true;
            ctx->platform_id = platform_ids[i];

            break;
        }
    if(!found){
        printf("Error: Unable to get a GPU device_id\n");
        exit(1);
    }


    // Create a compute context
    //
    ctx->context = clCreateContext(0, 1, &ctx->device_id, &pfn_notify, NULL, &err);
    if (!ctx->context)
    {
        printf("Error: Failed to create a compute context!\n");
        exit(1);
    }

    // Create a command commands
    //
    ctx->commands = clCreateCommandQueue(ctx->context, ctx->device_id, 0, &err);
    if (!ctx->commands)
    {
        printf("Error: Failed to create a command commands!\n");
        return;
    }
    ASRT_CL("Failed to Initialise OpenCL");


}

cl_mem gen_rgb_image(raytracer_context* rctx,
                     const unsigned int width,
                     const unsigned int height)
{
    cl_image_desc cl_standard_descriptor;
    cl_image_format     cl_standard_format;
    cl_standard_format.image_channel_order     = CL_RGBA;
    cl_standard_format.image_channel_data_type = CL_FLOAT;

    cl_standard_descriptor.image_type = CL_MEM_OBJECT_IMAGE2D;
    cl_standard_descriptor.image_width = width==0  ? rctx->width  : width;
    cl_standard_descriptor.image_height = height==0 ? rctx->height : height;
    cl_standard_descriptor.image_depth  = 0;
    cl_standard_descriptor.image_array_size  = 0;
    cl_standard_descriptor.image_row_pitch  = 0;
    cl_standard_descriptor.num_mip_levels = 0;
    cl_standard_descriptor.num_samples = 0;
    cl_standard_descriptor.buffer = NULL;

    int err;

    cl_mem img = clCreateImage(rctx->rcl->context,
                                CL_MEM_READ_WRITE,
                                &cl_standard_format,
                               &cl_standard_descriptor,
                                NULL,
                                &err);
    ASRT_CL("Couldn't Create OpenCL Texture");
    return img;
}
cl_mem gen_1d_image(raytracer_context* rctx, size_t t, void* ptr)
{

    cl_image_desc cl_standard_descriptor;
    cl_image_format     cl_standard_format;
    cl_standard_format.image_channel_order     = CL_RGBA;
    cl_standard_format.image_channel_data_type = CL_FLOAT;

    cl_standard_descriptor.image_type = CL_MEM_OBJECT_IMAGE1D;
    cl_standard_descriptor.image_width = t/4 == 0 ? 1 : t/4;
    cl_standard_descriptor.image_height = 0;
    cl_standard_descriptor.image_depth  = 0;
    cl_standard_descriptor.image_array_size  = 0;
    cl_standard_descriptor.image_row_pitch  = 0;
    cl_standard_descriptor.num_mip_levels = 0;
    cl_standard_descriptor.num_samples = 0;
    cl_standard_descriptor.buffer = NULL;

    int err;


    cl_mem img = clCreateImage(rctx->rcl->context,
                               CL_MEM_READ_WRITE | (/*ptr == NULL ? 0 :*/ CL_MEM_COPY_HOST_PTR),
                               &cl_standard_format,
                               &cl_standard_descriptor,
                               ptr,
                               &err);
    ASRT_CL("Couldn't Create OpenCL Texture");
    return img;
}
cl_mem gen_grayscale_buffer(raytracer_context* rctx,
                            const unsigned int width,
                            const unsigned int height)
{
    int err;

    cl_mem buf = clCreateBuffer(rctx->rcl->context, CL_MEM_READ_WRITE,
                                 (width==0  ? rctx->width  : width)*
                                 (height==0 ? rctx->height : height)*
                                 sizeof(float),
                                 NULL, &err);
    ASRT_CL("Couldn't Create OpenCL Float Buffer Image");
    return buf;
}

void retrieve_image(raytracer_context* rctx, cl_mem g_buf, void* c_buf,
                    const unsigned int width,
                    const unsigned int height)
{
    int err;
    size_t origin[3] = {0,0,0};
    size_t region[3] = {(width==0 ? rctx->width : width),
                        (height==0 ? rctx->height : height),
                        1};
    err = clEnqueueReadImage (rctx->rcl->commands,
                              g_buf,
                              CL_TRUE,
                              origin,
                              region,
                              0,
                              0,
                              c_buf,
                              0,
                              0,
                              NULL);
    ASRT_CL("Failed to retrieve Opencl Image");
}

void retrieve_buf(raytracer_context* rctx, cl_mem g_buf, void* c_buf, size_t size)
{
    int err;
    err = clEnqueueReadBuffer(rctx->rcl->commands, g_buf, CL_TRUE, 0,
                              size, c_buf,
                              0, NULL, NULL );
    ASRT_CL("Failed to retrieve Opencl Buffer");
}

void zero_buffer(raytracer_context* rctx, cl_mem buf, size_t size)
{
    int err;
    char pattern = 0;
    err =  clEnqueueFillBuffer (rctx->rcl->commands,
                                buf,
                                &pattern, 1 ,0,
                                size,
                                0, NULL, NULL);
    ASRT_CL("Couldn't Zero OpenCL Buffer");
}
void zero_buffer_img(raytracer_context* rctx, cl_mem buf, size_t element,
                 const unsigned int width,
                 const unsigned int height)
{
    int err;

    char pattern = 0;
    err =  clEnqueueFillBuffer (rctx->rcl->commands,
                                buf,
                                &pattern, 1 ,0,
                                (width==0  ? rctx->width  : width)*
                                (height==0 ? rctx->height : height)*
                                element,
                                0, NULL, NULL);
    ASRT_CL("Couldn't Zero OpenCL Buffer");
}
size_t get_workgroup_size(raytracer_context* rctx, cl_kernel kernel)
{
    int err;
    size_t local = 0;
    err = clGetKernelWorkGroupInfo(kernel, rctx->rcl->device_id,
                                   CL_KERNEL_WORK_GROUP_SIZE,
                                   sizeof(local), &local, NULL);
    ASRT_CL("Failed to Retrieve Kernel Work Group Info");
    return local;
}


void load_program_raw(rcl_ctx* ctx, char* data,
                     char** kernels, unsigned int num_kernels,
                      rcl_program* program, char** macros, unsigned int num_macros)
{
    int err;

    char* fin_data = (char*) malloc(strlen(data));
    strcpy(fin_data, data);

    for(int i = 0; i < num_macros; i++)
    {
        int length = strlen(macros[i]);
        char* buf  = (char*) malloc(length+strlen(fin_data)+3);
        sprintf(buf, "%s\n%s\0", macros[i], fin_data);
        free(fin_data);
        fin_data = buf;
    }

    program->program = clCreateProgramWithSource(ctx->context, 1, (const char **) &fin_data, NULL, &err);
    if (!program->program)
    {
        printf("Error: Failed to create compute program!\n");
        exit(1);
    }

    // Build the program executable
    //
    err = clBuildProgram(program->program, 0, NULL, NULL, NULL, NULL);
    if (err != CL_SUCCESS)
    {
        size_t len;
        char buffer[2048*256];
        buffer[0] = '!';
        buffer[1] = '\0';


        printf("Error: Failed to build program executable!\n");
        printf("KERNEL:\n %s\nprogram done\n", fin_data);
        int n_err = clGetProgramBuildInfo(program->program, ctx->device_id, CL_PROGRAM_BUILD_LOG, sizeof(buffer), buffer, &len);
        if(n_err != CL_SUCCESS)
        {
            printf("The error had an error, I hate this. err:%i\n",n_err);
        }
        printf("err code:%i\n %s\n", err, buffer);
        exit(1);
    }

    program->raw_kernels = malloc(sizeof(cl_kernel)*num_kernels);
    for(int i = 0; i < num_kernels; i++)
    {
        // Create the compute kernel in the program we wish to run
        //

        program->raw_kernels[i] = clCreateKernel(program->program, kernels[i], &err);
        if (!program->raw_kernels[i] || err != CL_SUCCESS)
        {
            printf("Error: Failed to create compute kernel! %s\n", kernels[i]);
            exit(1);
        }

    }

    program->raw_data = fin_data;

}

void load_program_url(rcl_ctx* ctx, char* url,
                     char** kernels, unsigned int num_kernels,
                      rcl_program* program, char** macros, unsigned int num_macros)
{
    char * buffer = 0;
    long length;
    FILE * f = fopen (url, "rb");

    if (f)
    {
        fseek (f, 0, SEEK_END);
        length = ftell (f);
        fseek (f, 0, SEEK_SET);
        buffer = malloc (length+2);
        if (buffer)
        {
            fread (buffer, 1, length, f);
        }
        fclose (f);
    }
    if (buffer)
    {
        buffer[length] = '\0';

        load_program_raw(ctx, buffer, kernels, num_kernels, program,
                         macros, num_macros);
    }

}

//NOTE: old
void test_sphere_raytracer(rcl_ctx* ctx, rcl_program* program,
        sphere* spheres, int num_spheres,
        uint32_t* bitmap, int width, int height)
{
    int err;

    static cl_mem tex;
    static cl_mem s_buf;
    static bool init = false; //temporary

    if(!init)
    {
        //New Texture
        tex = clCreateBuffer(ctx->context, CL_MEM_WRITE_ONLY,
                                    width*height*4, NULL, &err);

        //Spheres
        s_buf = clCreateBuffer(ctx->context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR,
                               sizeof(float)*4*num_spheres, spheres, &err);
        if (err != CL_SUCCESS)
        {
            printf("Error: Failed to create Sphere Buffer! %d\n", err);
            return;
        }
        init = true;
    }
    else
    {
        clEnqueueWriteBuffer (	ctx->commands,
                                s_buf,
                                CL_TRUE,
                                0,
                                sizeof(float)*4*num_spheres,
                                spheres,
                                0,
                                NULL,
                                NULL);
    }



    cl_kernel kernel = program->raw_kernels[0]; //just use the first one

    clSetKernelArg(kernel, 0, sizeof(cl_mem), &tex);
    clSetKernelArg(kernel, 1, sizeof(cl_mem), &s_buf);
    clSetKernelArg(kernel, 2, sizeof(unsigned int), &width);
    clSetKernelArg(kernel, 3, sizeof(unsigned int), &height);


    size_t global;
    size_t local = 0;

    err = clGetKernelWorkGroupInfo(kernel, ctx->device_id, CL_KERNEL_WORK_GROUP_SIZE,
        sizeof(local), &local, NULL);
    if (err != CL_SUCCESS)
    {
        printf("Error: Failed to retrieve kernel work group info! %d\n", err);
        return;
    }

    // Execute the kernel over the entire range of our 1d input data set
    // using the maximum number of work group items for this device
    //
    //printf("STARTING\n");
    global =  width*height;
    err = clEnqueueNDRangeKernel(ctx->commands, kernel, 1, NULL, &global, NULL, 0, NULL, NULL);
    if (err)
    {
        printf("Error: Failed to execute kernel! %i\n",err);
        return;
    }


    clFinish(ctx->commands);
    //printf("STOPPING\n");

    err = clEnqueueReadBuffer(ctx->commands, tex, CL_TRUE, 0, width*height*4, bitmap, 0, NULL, NULL );
    if (err != CL_SUCCESS)
    {
        printf("Error: Failed to read output array! %d\n", err);
        exit(1);
    }
}

/***************/
/* raytracer.c */
/***************/

#include <raytracer.h>
#include <parallel.h>

//binary resources
#include <test.cl.h> //test kernel



//NOTE: we are assuming the output buffer will be the right size
raytracer_context* raytracer_init(unsigned int width, unsigned int height,
                                      uint32_t* output_buffer, rcl_ctx* rcl)
{
    raytracer_context* rctx = (raytracer_context*) malloc(sizeof(raytracer_context));
    rctx->width  = width;
    rctx->height = height;
    rctx->ray_buffer = (float*) malloc(width * height * sizeof(float)*3);
    rctx->output_buffer = output_buffer;
    //rctx->fresh_buffer = (uint32_t*) malloc(width * height * sizeof(uint32_t));
    rctx->rcl = rcl;
    rctx->program = (rcl_program*) malloc(sizeof(rcl_program));
    rctx->ic_ctx = (ic_context*) malloc(sizeof(ic_context));
    //ic_init(rctx);
    rctx->render_complete = false;
    rctx->num_samples     = 64; //NOTE: arbitrary default
    rctx->current_sample  = 0;

    return rctx;
}

void raytracer_cl_prepass(raytracer_context* rctx)
{
    //CL init
    printf("Building Scene Kernels...\n");

    int err = CL_SUCCESS;

    //Kernels
    char* kernels[] = KERNELS;

    //Macros
    char sphere_macro[64];
    sprintf(sphere_macro, "#define SCENE_NUM_SPHERES %i", rctx->stat_scene->num_spheres);
    char plane_macro[64];
    sprintf(plane_macro, "#define SCENE_NUM_PLANES %i", rctx->stat_scene->num_planes);
    char index_macro[64];
    sprintf(index_macro, "#define SCENE_NUM_INDICES %i", rctx->stat_scene->num_mesh_indices);
    char mesh_macro[64];
    sprintf(mesh_macro, "#define SCENE_NUM_MESHES %i", rctx->stat_scene->num_meshes);
    char material_macro[64];
    sprintf(material_macro, "#define SCENE_NUM_MATERIALS %i", rctx->stat_scene->num_materials);
    char* macros[]  = {sphere_macro, plane_macro, mesh_macro, index_macro, material_macro};

    {

        load_program_raw(rctx->rcl,
                         all_kernels_cl, //NOTE: Binary resource
                         kernels, NUM_KERNELS, rctx->program,
                         macros, 5);
    }
    //Buffers
    rctx->cl_ray_buffer = clCreateBuffer(rctx->rcl->context,
                                         CL_MEM_READ_WRITE | CL_MEM_COPY_HOST_PTR,
                                         rctx->width*rctx->height*sizeof(float)*3,
                                         rctx->ray_buffer, &err);
    ASRT_CL("Error Creating OpenCL Ray Buffer.");
    rctx->cl_path_output_buffer = clCreateBuffer(rctx->rcl->context,
                                         CL_MEM_READ_WRITE,
                                         rctx->width*rctx->height*sizeof(vec4),
                                         NULL, &err);
    ASRT_CL("Error Creating OpenCL Path Tracer Output Buffer.");

    rctx->cl_output_buffer = clCreateBuffer(rctx->rcl->context, CL_MEM_READ_WRITE,
                                            rctx->width*rctx->height*4, NULL, &err);
    ASRT_CL("Error Creating OpenCL Output Buffer.");

    //TODO: all output buffers and frame buffers should be images.
    rctx->cl_path_fresh_frame_buffer = clCreateBuffer(rctx->rcl->context, CL_MEM_READ_WRITE,
                                                 rctx->width*rctx->height*sizeof(vec4), NULL, &err);
    ASRT_CL("Error Creating OpenCL Fresh Frame Buffer.");

	printf("Pushing Scene Resources.\n");
	scene_init_resources(rctx);

    printf("Built Scene Kernels.\n");
}

void raytracer_prepass(raytracer_context* rctx)
{
    printf("Starting Raytracer Prepass.\n");


    raytracer_cl_prepass(rctx);


    printf("Finished Raytracer Prepass.\n");

} //TODO: implement
void raytracer_render(raytracer_context* rctx)
{
    _raytracer_gen_ray_buffer(rctx);

    _raytracer_cast_rays(rctx);
}

//#define JANK_SAMPLES 32
void raytracer_refined_render(raytracer_context* rctx)
{
    rctx->current_sample++;
    if(rctx->current_sample>rctx->num_samples)
    {
        rctx->render_complete = true;
        return;
    }
    _raytracer_gen_ray_buffer(rctx);

    _raytracer_path_trace(rctx, rctx->current_sample);

    if(rctx->current_sample==1) //really terrible place for path tracer initialization...
    {
        int err;
        char pattern = 0;
        err = clEnqueueCopyBuffer (	rctx->rcl->commands,
                                    rctx->cl_path_fresh_frame_buffer,
                                    rctx->cl_path_output_buffer,
                                    0,
                                    0,
                                    rctx->width*rctx->height*sizeof(vec4),
                                    0,
                                    0,
                                    NULL);
        ASRT_CL("Error copying OpenCL Output Buffer");

        err = clFinish(rctx->rcl->commands);
        ASRT_CL("Something happened while waiting for copy to finish");
    }

    _raytracer_average_buffers(rctx, rctx->current_sample);
    _raytracer_push_path(rctx);

}

void _raytracer_gen_ray_buffer(raytracer_context* rctx)
{
    int err;

    cl_kernel kernel = rctx->program->raw_kernels[RAY_BUFFER_KRNL_INDX];
    clSetKernelArg(kernel, 0, sizeof(cl_mem), &rctx->cl_ray_buffer);
    clSetKernelArg(kernel, 1, sizeof(unsigned int), &rctx->width);
    clSetKernelArg(kernel, 2, sizeof(unsigned int), &rctx->height);
    clSetKernelArg(kernel, 3, sizeof(mat4), rctx->stat_scene->camera_world_matrix);


    size_t global;


    global =  rctx->width*rctx->height;
    err = clEnqueueNDRangeKernel(rctx->rcl->commands, kernel, 1, NULL, &global, NULL, 0, NULL, NULL);
    ASRT_CL("Failed to execute kernel");


    //Wait for completion
    err = clFinish(rctx->rcl->commands);
    ASRT_CL("Something happened while waiting for kernel raybuf to finish");


}
void _raytracer_average_buffers(raytracer_context* rctx, unsigned int sample_num)
{
    int err;

    cl_kernel kernel = rctx->program->raw_kernels[F_BUFFER_AVG_KRNL_INDX];
    clSetKernelArg(kernel, 0, sizeof(cl_mem), &rctx->cl_path_output_buffer);
    clSetKernelArg(kernel, 1, sizeof(cl_mem), &rctx->cl_path_fresh_frame_buffer);
    clSetKernelArg(kernel, 2, sizeof(unsigned int), &rctx->width);
    clSetKernelArg(kernel, 3, sizeof(unsigned int), &rctx->height);
    clSetKernelArg(kernel, 4, sizeof(unsigned int), &rctx->num_samples);
    clSetKernelArg(kernel, 5, sizeof(unsigned int), &sample_num);

    size_t global;
    size_t local = get_workgroup_size(rctx, kernel);

    // Execute the kernel over the entire range of our 1d input data set
    // using the maximum number of work group items for this device
    //
    global =  rctx->width*rctx->height;
    err = clEnqueueNDRangeKernel(rctx->rcl->commands, kernel, 1, NULL, &global, NULL, 0, NULL, NULL);
    ASRT_CL("Failed to execute kernel")
    err = clFinish(rctx->rcl->commands);
    ASRT_CL("Something happened while waiting for kernel to finish");



}

void _raytracer_push_path(raytracer_context* rctx)
{
    int err;

    cl_kernel kernel = rctx->program->raw_kernels[F_BUF_TO_BYTE_BUF_KRNL_INDX];
    clSetKernelArg(kernel, 0, sizeof(cl_mem), &rctx->cl_output_buffer);
    clSetKernelArg(kernel, 1, sizeof(cl_mem), &rctx->cl_path_output_buffer);
    clSetKernelArg(kernel, 2, sizeof(unsigned int), &rctx->width);
    clSetKernelArg(kernel, 3, sizeof(unsigned int), &rctx->height);



    size_t global;
    size_t local = get_workgroup_size(rctx, kernel);

    // Execute the kernel over the entire range of our 1d input data set
    // using the maximum number of work group items for this device
    //
    global =  rctx->width*rctx->height;
    err = clEnqueueNDRangeKernel(rctx->rcl->commands, kernel, 1, NULL, &global, NULL, 0, NULL, NULL);
    ASRT_CL("Failed to execute kernel");


    err = clFinish(rctx->rcl->commands);
    ASRT_CL("Something happened while waiting for kernel to finish");

    err = clEnqueueReadBuffer(rctx->rcl->commands, rctx->cl_output_buffer, CL_TRUE, 0,
                              rctx->width*rctx->height*sizeof(int), rctx->output_buffer,
                              0, NULL, NULL );
    ASRT_CL("Failed to read output array");

}

//NOTE: the more divisions the slower.
#define WATCHDOG_DIVISIONS_X 2
#define WATCHDOG_DIVISIONS_Y 2
void _raytracer_path_trace(raytracer_context* rctx, unsigned int sample_num)
{
    int err;

    const unsigned x_div = rctx->width/WATCHDOG_DIVISIONS_X;
    const unsigned y_div = rctx->height/WATCHDOG_DIVISIONS_Y;

    //scene_resource_push(rctx); //Update Scene buffers if necessary.

    cl_kernel kernel = rctx->program->raw_kernels[PATH_TRACE_KRNL_INDX]; //just use the first one

    float zeroed[] = {0., 0., 0., 1.};
    float* result = matvec_mul(rctx->stat_scene->camera_world_matrix, zeroed);

    clSetKernelArg(kernel, 0, sizeof(cl_mem), &rctx->cl_path_fresh_frame_buffer);
    clSetKernelArg(kernel, 1, sizeof(cl_mem), &rctx->cl_ray_buffer);
    clSetKernelArg(kernel, 2, sizeof(cl_mem), &rctx->stat_scene->cl_material_buffer);
    clSetKernelArg(kernel, 3, sizeof(cl_mem), &rctx->stat_scene->cl_sphere_buffer);
    clSetKernelArg(kernel, 4, sizeof(cl_mem), &rctx->stat_scene->cl_plane_buffer);
    clSetKernelArg(kernel, 5, sizeof(cl_mem), &rctx->stat_scene->cl_mesh_buffer);
    clSetKernelArg(kernel, 6, sizeof(cl_mem), &rctx->stat_scene->cl_mesh_index_buffer);
    clSetKernelArg(kernel, 7, sizeof(cl_mem), &rctx->stat_scene->cl_mesh_vert_buffer);
    clSetKernelArg(kernel, 8, sizeof(cl_mem), &rctx->stat_scene->cl_mesh_nrml_buffer);

    clSetKernelArg(kernel, 9,  sizeof(int),     &rctx->width);
    clSetKernelArg(kernel, 10, sizeof(vec4),    result);
    clSetKernelArg(kernel, 11, sizeof(int),     &sample_num); //NOTE: I don't think this is used

    size_t global[2] = {x_div, y_div};

    //NOTE: tripping watchdog timer
    if(global[0]*WATCHDOG_DIVISIONS_X*global[1]*WATCHDOG_DIVISIONS_Y!=rctx->width*rctx->height)
    {
        printf("Watchdog divisions are incorrect!\n");
        exit(1);
    }

    size_t offset[2];

    for(int x = 0; x < WATCHDOG_DIVISIONS_X; x++)
    {
        for(int y = 0; y < WATCHDOG_DIVISIONS_Y; y++)
        {
            offset[0] = x_div*x;
            offset[1] = y_div*y;
            err = clEnqueueNDRangeKernel(rctx->rcl->commands, kernel, 2,
                                         offset, global, NULL, 0, NULL, NULL);
            ASRT_CL("Failed to execute path trace kernel");
        }
    }

    err = clFinish(rctx->rcl->commands);
    ASRT_CL("Something happened while executing path trace kernel");
}


void _raytracer_cast_rays(raytracer_context* rctx) //TODO: do more path tracing stuff here
{
    int err;



    scene_resource_push(rctx); //Update Scene buffers if necessary.


    cl_kernel kernel = rctx->program->raw_kernels[RAY_CAST_KRNL_INDX]; //just use the first one

    float zeroed[] = {0., 0., 0., 1.};
    float* result = matvec_mul(rctx->stat_scene->camera_world_matrix, zeroed);
    clSetKernelArg(kernel, 0, sizeof(cl_mem), &rctx->cl_output_buffer);
    clSetKernelArg(kernel, 1, sizeof(cl_mem), &rctx->cl_ray_buffer);
    clSetKernelArg(kernel, 2, sizeof(cl_mem), &rctx->stat_scene->cl_material_buffer);
    clSetKernelArg(kernel, 3, sizeof(cl_mem), &rctx->stat_scene->cl_sphere_buffer);
    clSetKernelArg(kernel, 4, sizeof(cl_mem), &rctx->stat_scene->cl_plane_buffer);
    clSetKernelArg(kernel, 5, sizeof(cl_mem), &rctx->stat_scene->cl_mesh_buffer);
    clSetKernelArg(kernel, 6, sizeof(cl_mem), &rctx->stat_scene->cl_mesh_index_buffer);
    clSetKernelArg(kernel, 7, sizeof(cl_mem), &rctx->stat_scene->cl_mesh_vert_buffer);
    clSetKernelArg(kernel, 8, sizeof(cl_mem), &rctx->stat_scene->cl_mesh_nrml_buffer);

    clSetKernelArg(kernel, 9, sizeof(unsigned int), &rctx->width);
    clSetKernelArg(kernel, 10, sizeof(unsigned int), &rctx->height);
    clSetKernelArg(kernel, 11, sizeof(float)*4, result); //we only need 3
    //free(result);

    size_t global;

    global =  rctx->width*rctx->height;
    err = clEnqueueNDRangeKernel(rctx->rcl->commands, kernel, 1, NULL, &global, NULL, 0, NULL, NULL);
    ASRT_CL("Failed to Execute Kernel");

    err = clFinish(rctx->rcl->commands);
    ASRT_CL("Something happened during kernel execution");

    err = clEnqueueReadBuffer(rctx->rcl->commands, rctx->cl_output_buffer, CL_TRUE, 0,
                              rctx->width*rctx->height*sizeof(int), rctx->output_buffer, 0, NULL, NULL );
    ASRT_CL("Failed to read output array");

}

